<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="https://github.com/scalableminds/amd-optimize#readme"

    >amd-optimize (v0.6.1)</a>
</h1>
<h4>An AMD (i.e. RequireJS) optimizer that's stream-friendly. Made for gulp. (WIP)</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.amd-optimize">module amd-optimize</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amd-optimize.amd-optimize">
            function <span class="apidocSignatureSpan"></span>amd-optimize
            <span class="apidocSignatureSpan">(entryModuleName, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amd-optimize.export">
            function <span class="apidocSignatureSpan">amd-optimize.</span>export
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amd-optimize.loader">
            function <span class="apidocSignatureSpan">amd-optimize.</span>loader
            <span class="apidocSignatureSpan">(filenameResolver, pipe)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amd-optimize.parse">
            function <span class="apidocSignatureSpan">amd-optimize.</span>parse
            <span class="apidocSignatureSpan">(config, file, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amd-optimize.src">
            function <span class="apidocSignatureSpan">amd-optimize.</span>src
            <span class="apidocSignatureSpan">(moduleName, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amd-optimize.toString">
            function <span class="apidocSignatureSpan">amd-optimize.</span>toString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amd-optimize.trace">
            function <span class="apidocSignatureSpan">amd-optimize.</span>trace
            <span class="apidocSignatureSpan">(startModuleName, config, allModules, fileLoader, callback)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">amd-optimize.</span>util</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.amd-optimize.export">module amd-optimize.export</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amd-optimize.export.export">
            function <span class="apidocSignatureSpan">amd-optimize.</span>export
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.amd-optimize.loader">module amd-optimize.loader</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amd-optimize.loader.loader">
            function <span class="apidocSignatureSpan">amd-optimize.</span>loader
            <span class="apidocSignatureSpan">(filenameResolver, pipe)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.amd-optimize.parse">module amd-optimize.parse</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amd-optimize.parse.parse">
            function <span class="apidocSignatureSpan">amd-optimize.</span>parse
            <span class="apidocSignatureSpan">(config, file, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.amd-optimize.src">module amd-optimize.src</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amd-optimize.src.src">
            function <span class="apidocSignatureSpan">amd-optimize.</span>src
            <span class="apidocSignatureSpan">(moduleName, options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.amd-optimize.toString">module amd-optimize.toString</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amd-optimize.toString.toString">
            function <span class="apidocSignatureSpan">amd-optimize.</span>toString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.amd-optimize.trace">module amd-optimize.trace</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amd-optimize.trace.trace">
            function <span class="apidocSignatureSpan">amd-optimize.</span>trace
            <span class="apidocSignatureSpan">(startModuleName, config, allModules, fileLoader, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.amd-optimize.util">module amd-optimize.util</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amd-optimize.util.fixModuleName">
            function <span class="apidocSignatureSpan">amd-optimize.util.</span>fixModuleName
            <span class="apidocSignatureSpan">(moduleName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amd-optimize.util.logger">
            function <span class="apidocSignatureSpan">amd-optimize.util.</span>logger
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amd-optimize.util.printTree">
            function <span class="apidocSignatureSpan">amd-optimize.util.</span>printTree
            <span class="apidocSignatureSpan">(currentModule, prefix)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.amd-optimize" id="apidoc.module.amd-optimize">module amd-optimize</a></h1>


    <h2>
        <a href="#apidoc.element.amd-optimize.amd-optimize" id="apidoc.element.amd-optimize.amd-optimize">
        function <span class="apidocSignatureSpan"></span>amd-optimize
        <span class="apidocSignatureSpan">(entryModuleName, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">amd-optimize = function (entryModuleName, options) {
  var configFileStream, fileBuffer, mainStream;
  if (options == null) {
    options = {};
  }
  options = _.defaults(options, {
    baseUrl: &#x22;&#x22;,
    configFile: null,
    exclude: [],
    excludeShallow: [],
    findNestedDependencies: false,
    loader: null,
    preserveComments: false,
    preserveFiles: false
  });
  if (_.isString(options.exclude)) {
    options.exclude = [options.exclude];
  }
  if (_.isString(options.excludeShallow)) {
    options.excludeShallow = [options.excludeShallow];
  }
  if (_.isString(options.configFile) || _.isArray(options.configFile)) {
    configFileStream = vinylFs.src(options.configFile);
  } else if (_.isObject(options.configFile)) {
    configFileStream = options.configFile;
  }
  fileBuffer = [];
  mainStream = through.obj(function(file, enc, done) {
    fileBuffer.push(file);
    return done();
  }, function(done) {
    return async.waterfall([
      function(callback) {
        if (configFileStream) {
          return configFileStream.pipe(through.obj(function(file, enc, done) {
            options = mergeOptionsFile(file, options);
            return done();
          }, function() {
            return callback();
          }));
        } else {
          return callback();
        }
      }, function(callback) {
        return trace(entryModuleName, options, null, defaultLoader(fileBuffer, options), callback);
      }, function(module, callback) {
        return callback(null, collectModules(module));
      }, function(modules, callback) {
        if (_.isArray(options.exclude)) {
          return async.map(options.exclude, function(moduleName, callback) {
            return trace(moduleName, options, null, defaultLoader(fileBuffer, options), callback);
          }, function(err, excludedModules) {
            if (err) {
              return callback(err);
            } else {
              return callback(null, modules, _(excludedModules).map(function(module) {
                return collectModules(module);
              }).flatten().pluck(&#x22;name&#x22;).unique().value());
            }
          });
        } else {
          return callback(null, modules, []);
        }
      }, function(modules, excludedModuleNames, callback) {
        var exportStream;
        modules = _.reject(modules, function(module) {
          return _.contains(excludedModuleNames, module.name) || _.contains(options.excludeShallow, module.name);
        });
        exportStream = exportModule(options);
        exportStream.on(&#x22;data&#x22;, function(file) {
          return mainStream.push(file);
        }).on(&#x22;end&#x22;, function() {
          return callback();
        }).on(&#x22;error&#x22;, callback);
        modules.forEach(exportStream.write.bind(exportStream));
        return exportStream.end();
      }
    ], done);
  });
  return mainStream;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amd-optimize.export" id="apidoc.element.amd-optimize.export">
        function <span class="apidocSignatureSpan">amd-optimize.</span>export
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">export = function (options) {
  if (options == null) {
    options = {};
  }
  options = _.defaults(options, {
    wrapShim: true
  });
  return through.obj(function(module, enc, done) {
    var ast, defineBody, defineCall, defineReturnStatement, generatedCode, sourceFile;
    if (module.isShallow) {
      done();
      return;
    }
    ast = module.file.ast;
    delete module.file.ast;
    if (!module.hasDefine) {
      defineReturnStatement = b.returnStatement(module.exports ? b.identifier(module.exports) : null);
      if (options.wrapShim &#x26;&#x26; module.isShimmed) {
        defineBody = ast.body.concat([defineReturnStatement]);
      } else {
        defineBody = [defineReturnStatement];
      }
      defineCall = b.callExpression(b.identifier(&#x22;define&#x22;), [
        b.literal(module.name), b.arrayExpression(module.deps.map(function(dep) {
          return b.literal(dep.name);
        })), b.functionExpression(null, [], b.blockStatement(defineBody))
      ]);
      if (options.wrapShim &#x26;&#x26; module.isShimmed) {
        ast.body = [b.expressionStatement(defineCall)];
      } else {
        ast.body.push(b.expressionStatement(defineCall));
      }
    } else if (module.isAnonymous) {
      module.astNodes.forEach((function(_this) {
        return function(astNode) {
          if (astNode.callee.name === &#x22;define&#x22; &#x26;&#x26; (astNode[&#x22;arguments&#x22;].length === 1 || (astNode[&#x22;arguments&#x22;].length === 2 &#x26;&#x26; astNode
[&#x22;arguments&#x22;][0].type === &#x22;ArrayExpression&#x22;))) {
            return astNode[&#x22;arguments&#x22;] = [
              b.literal(module.name), b.arrayExpression(module.deps.map(function(dep) {
                return b.literal(dep.name);
              })), _.last(astNode[&#x22;arguments&#x22;])
            ];
          }
        };
      })(this));
    }
    if (module.hasDefine &#x26;&#x26; module.isShimmed) {
      ast.body = [b.expressionStatement(b.callExpression(b.memberExpression(b.functionExpression(null, [], b.blockStatement(ast.
body)), b.identifier(&#x22;call&#x22;), false), [b.thisExpression()]))];
    }
    sourceFile = module.file.clone();
    sourceFile.sourceMap = module.file.sourceMap;
    if (sourceFile.sourceMap) {
      generatedCode = escodegen.generate(ast, {
        comment: options.preserveComments,
        sourceMap: true,
        sourceMapWithCode: true,
        file: sourceFile.sourceMap.file
      });
      sourceFile.contents = new Buffer(generatedCode.code, &#x22;utf8&#x22;);
      vinylSourcemapsApply(sourceFile, generatedCode.map.toJSON());
    } else if (!options.preserveFiles) {
      sourceFile = module.file.clone();
      sourceFile.contents = new Buffer(escodegen.generate(ast, {
        comment: options.preserveComments
      }), &#x22;utf8&#x22;);
    }
    this.push(sourceFile);
    return done();
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amd-optimize.loader" id="apidoc.element.amd-optimize.loader">
        function <span class="apidocSignatureSpan">amd-optimize.</span>loader
        <span class="apidocSignatureSpan">(filenameResolver, pipe)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">loader = function (filenameResolver, pipe) {
  return function(moduleName, callback) {
    var filename, source;
    if (filenameResolver) {
      filename = filenameResolver(moduleName);
    } else {
      filename = moduleName;
    }
    source = vinylFs.src(filename).pipe(through.obj());
    if (pipe) {
      source = source.pipe(pipe());
    }
    firstChunk(source, callback);
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

#### options.loader
WIP. Subject to change.

```js
amdOptimize.src(
  &#x22;index&#x22;,
  loader : amdOptimize.<span class="apidocCodeKeywordSpan">loader</span>(
    // Used for turning a moduleName into a filepath glob.
    function (moduleName) { return &#x22;src/scripts/&#x22; + moduleName + &#x22;.coffee&#x22; },
    // Returns a transform stream.
    function () { return coffee(); }
  )
)
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amd-optimize.parse" id="apidoc.element.amd-optimize.parse">
        function <span class="apidocSignatureSpan">amd-optimize.</span>parse
        <span class="apidocSignatureSpan">(config, file, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parse = function (config, file, callback) {
  var ast, comments, definitions, err, tokens;
  try {
    if (config.preserveComments) {
      comments = [];
      tokens = [];
      ast = acorn.parse(file.stringContents, {
        sourceFile: file.relative,
        locations: file.sourceMap != null,
        ranges: true,
        onComment: comments,
        onToken: tokens
      });
      escodegen.attachComments(ast, comments, tokens);
    } else {
      ast = acorn.parse(file.stringContents, {
        sourceFile: file.relative,
        locations: file.sourceMap != null
      });
    }
  } catch (_error) {
    err = _error;
    if (err instanceof SyntaxError) {
      err.filename = file.path;
      err.message += &#x22; in &#x22; + file.path;
    }
    callback(err);
    return;
  }
  file.ast = ast;
  definitions = [];
  walk.ancestor(ast, {
    CallExpression: function(node, state) {
      var defineAncestors, deps, isInsideDefine, moduleName;
      if (node.callee.name === &#x22;define&#x22;) {
        switch (node[&#x22;arguments&#x22;].length) {
          case 1:
            if (node[&#x22;arguments&#x22;][0].type === &#x22;FunctionExpression&#x22; &#x26;&#x26; node[&#x22;arguments&#x22;][0].params.length &#x3e; 0) {
              deps = [&#x27;require&#x27;, &#x27;exports&#x27;, &#x27;module&#x27;];
              walk.simple(node[&#x22;arguments&#x22;][0], {
                CallExpression: function(node) {
                  if (node.callee.name === &#x22;require&#x22; || node.callee.name === &#x22;requirejs&#x22;) {
                    return deps.push(node[&#x22;arguments&#x22;][0].value);
                  }
                }
              });
            }
            break;
          case 2:
            switch (node[&#x22;arguments&#x22;][0].type) {
              case &#x22;Literal&#x22;:
                moduleName = node[&#x22;arguments&#x22;][0].value;
                break;
              case &#x22;ArrayExpression&#x22;:
                deps = valuesFromArrayExpression(node[&#x22;arguments&#x22;][0]);
            }
            break;
          case 3:
            moduleName = node[&#x22;arguments&#x22;][0].value;
            deps = valuesFromArrayExpression(node[&#x22;arguments&#x22;][1]);
        }
        definitions.push({
          method: &#x22;define&#x22;,
          moduleName: moduleName,
          deps: deps != null ? deps : [],
          argumentsLength: node[&#x22;arguments&#x22;].length,
          node: node
        });
        isInsideDefine = true;
      }
      if ((node.callee.name === &#x22;require&#x22; || node.callee.name === &#x22;requirejs&#x22;) &#x26;&#x26; node[&#x22;arguments&#x22;].length &#x3e; 0 &#x26;&#x26; node[&#x22;arguments
&#x22;][0].type === &#x22;ArrayExpression&#x22;) {
        defineAncestors = _.any(state.slice(0, -1), function(ancestorNode) {
          return ancestorNode.type === &#x22;CallExpression&#x22; &#x26;&#x26; (ancestorNode.callee.name === &#x22;define&#x22; || ancestorNode.callee.name === &#x22;
require&#x22; || ancestorNode.callee.name === &#x22;requirejs&#x22;);
        });
        if (config.findNestedDependencies || !defineAncestors) {
          return definitions.push({
            method: &#x22;require&#x22;,
            moduleName: void 0,
            deps: valuesFromArrayExpression(node[&#x22;arguments&#x22;][0]),
            node: node
          });
        }
      }
    }
  });
  callback(null, file, definitions);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  module.exports = parseRequireDefinitions = function(config, file, callback) {
var ast, comments, definitions, err, tokens;
try {
  if (config.preserveComments) {
    comments = [];
    tokens = [];
    ast = acorn.<span class="apidocCodeKeywordSpan">parse</span>(file.stringContents, {
      sourceFile: file.relative,
      locations: file.sourceMap != null,
      ranges: true,
      onComment: comments,
      onToken: tokens
    });
    escodegen.attachComments(ast, comments, tokens);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amd-optimize.src" id="apidoc.element.amd-optimize.src">
        function <span class="apidocSignatureSpan">amd-optimize.</span>src
        <span class="apidocSignatureSpan">(moduleName, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">src = function (moduleName, options) {
  var source;
  source = rjs(moduleName, options);
  process.nextTick(function() {
    return source.end();
  });
  return source;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```js
var gulp = require(&#x22;gulp&#x22;);
var amdOptimize = require(&#x22;amd-optimize&#x22;);
var concat = require(&#x27;gulp-concat&#x27;);

gulp.task(&#x22;scripts:index&#x22;, function () {

  return gulp.<span class="apidocCodeKeywordSpan">src</span>(&#x22;src/scripts/**/*.js&#x22;)
    // Traces all modules and outputs them in the correct order.
    .pipe(amdOptimize(&#x22;main&#x22;))
    .pipe(concat(&#x22;index.js&#x22;))
    .pipe(gulp.dest(&#x22;dist/scripts&#x22;));

});
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amd-optimize.toString" id="apidoc.element.amd-optimize.toString">
        function <span class="apidocSignatureSpan">amd-optimize.</span>toString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function () {
    return text;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
  if (file) {
    return callback(null, file);
  } else {
    return callback(new Error(&#x22;No file for module &#x27;&#x22; + moduleName + &#x22;&#x27; found.&#x22;));
  }
}, function(file, callback) {
  file.stringContents = file.contents.<span class="apidocCodeKeywordSpan">toString</span>(&#x22;utf8&#x22;);
  if (isTextFile) {
    file.stringContents = &#x27;define(function(){ return &#x27; + JSON.stringify(file.stringContents) + &#x27;; });&#x27;;
  }
  if (isJsonFile) {
    file.stringContents = &#x27;define(function(){ return JSON.parse(&#x27; + JSON.stringify(file.stringContents) + &#x27;); });&#
x27;;
  }
  module = new Module(moduleName, file);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amd-optimize.trace" id="apidoc.element.amd-optimize.trace">
        function <span class="apidocSignatureSpan">amd-optimize.</span>trace
        <span class="apidocSignatureSpan">(startModuleName, config, allModules, fileLoader, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">trace = function (startModuleName, config, allModules, fileLoader, callback) {
  var emitModule, foundModuleNames, jsonFiles, resolveInlinedModule, resolveModule, resolveModuleFileName, resolveModuleName, resolveModules
, textFiles;
  if (allModules == null) {
    allModules = [];
  }
  foundModuleNames = [];
  textFiles = {};
  jsonFiles = {};
  resolveModuleName = function(moduleName, relativeTo) {
    var eligiblePath, isJson, isText, relativeToFileName, slashIdx;
    if (relativeTo == null) {
      relativeTo = &#x22;&#x22;;
    }
    isText = moduleName.indexOf(&#x27;text!&#x27;) !== -1;
    if (isText) {
      moduleName = moduleName.replace(&#x27;text!&#x27;, &#x27;&#x27;);
    }
    isJson = moduleName.indexOf(&#x27;json!&#x27;) !== -1;
    if (isJson) {
      moduleName = moduleName.replace(&#x27;json!&#x27;, &#x27;&#x27;);
    }
    if (config.paths &#x26;&#x26; !config.paths[moduleName]) {
      slashIdx = moduleName.indexOf(&#x22;/&#x22;);
      if (slashIdx &#x3e; 0) {
        eligiblePath = config.paths[moduleName.substr(0, slashIdx)];
        if (eligiblePath) {
          moduleName = eligiblePath + moduleName.substr(slashIdx);
        }
      }
    }
    relativeToFileName = resolveModuleFileName(relativeTo);
    if (moduleName[0] === &#x22;.&#x22;) {
      moduleName = util.fixModuleName(path.join(path.dirname(relativeToFileName), moduleName));
    }
    if (config.map &#x26;&#x26; config.map[relativeTo] &#x26;&#x26; config.map[relativeTo][moduleName]) {
      moduleName = config.map[relativeTo][moduleName];
    }
    if (isText) {
      textFiles[moduleName] = true;
    }
    if (isJson) {
      jsonFiles[moduleName] = true;
    }
    return moduleName;
  };
  resolveModuleFileName = function(moduleName) {
    if (config.paths &#x26;&#x26; config.paths[moduleName]) {
      moduleName = config.paths[moduleName];
    }
    if (/!|^exports$|^require$|^module$|^empty:/.test(moduleName)) {

    } else {
      return moduleName;
    }
  };
  resolveModules = function(moduleNames, callback) {
    async.mapSeries(moduleNames, resolveModule, callback);
  };
  resolveInlinedModule = function(moduleName, deps, astNode, vinylFile, callback) {
    async.waterfall([
      function(callback) {
        return resolveModules(deps, callback);
      }, function(modules, callback) {
        var module;
        module = new Module(moduleName, vinylFile, _.compact(modules));
        module.hasDefine = true;
        module.isInline = true;
        module.astNodes.push(astNode);
        emitModule(module);
        return callback();
      }
    ], callback);
  };
  resolveModule = function(moduleName, callback) {
    var fileName, isJsonFile, isTextFile, module;
    module = _.detect(allModules, {
      name: moduleName
    });
    if (module) {
      callback(null, module);
      return;
    }
    fileName = resolveModuleFileName(moduleName);
    if (!fileName) {
      module = new Module(moduleName);
      module.isShallow = true;
      callback(null, emitModule(module));
      return;
    }
    if (_.contains(foundModuleNames, moduleName)) {
      callback(new Error(&#x22;Circular dependency detected. Module &#x27;&#x22; + moduleName + &#x22;&#x27; has been processed before.&#x22;));
      return;
    } else {
      foundModuleNames.push(moduleName);
    }
    module = null;
    isTextFile = !!textFiles[moduleName];
    isJsonFile = !!jsonFiles[moduleName];
    async.waterfall([
      function(callback) {
        return fileLoader(fileName, callback, isTextFile || isJsonFile);
      }, function(file, callback) {
        if (arguments.length === 1) {
          callback = file;
          file = null;
        }
        if (file) {
          return callback(null, file);
        } else {
          return callback(new Error(&#x22;No file for module &#x27;&#x22; + moduleName + &#x22;&#x27; found.&#x22;));
        }
      }, function(file, callback) {
        file.stringContents = file.contents.toString(&#x22;utf8&#x22;);
        if (isTextFile) {
          file.stringContents = &#x27;define(function(){ return &#x27; + JSON.stringify(file.stringContents) + &#x27;; });&#x27;;
        }
        if (isJsonFile) {
          file.stringContents = &#x27;define(function(){ return JSON.parse(&#x27; + JSON.stringify(file.stringContents) + &#x27;); });&#x27;;
        }
        module = new ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.amd-optimize.export" id="apidoc.module.amd-optimize.export">module amd-optimize.export</a></h1>


    <h2>
        <a href="#apidoc.element.amd-optimize.export.export" id="apidoc.element.amd-optimize.export.export">
        function <span class="apidocSignatureSpan">amd-optimize.</span>export
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">export = function (options) {
  if (options == null) {
    options = {};
  }
  options = _.defaults(options, {
    wrapShim: true
  });
  return through.obj(function(module, enc, done) {
    var ast, defineBody, defineCall, defineReturnStatement, generatedCode, sourceFile;
    if (module.isShallow) {
      done();
      return;
    }
    ast = module.file.ast;
    delete module.file.ast;
    if (!module.hasDefine) {
      defineReturnStatement = b.returnStatement(module.exports ? b.identifier(module.exports) : null);
      if (options.wrapShim &#x26;&#x26; module.isShimmed) {
        defineBody = ast.body.concat([defineReturnStatement]);
      } else {
        defineBody = [defineReturnStatement];
      }
      defineCall = b.callExpression(b.identifier(&#x22;define&#x22;), [
        b.literal(module.name), b.arrayExpression(module.deps.map(function(dep) {
          return b.literal(dep.name);
        })), b.functionExpression(null, [], b.blockStatement(defineBody))
      ]);
      if (options.wrapShim &#x26;&#x26; module.isShimmed) {
        ast.body = [b.expressionStatement(defineCall)];
      } else {
        ast.body.push(b.expressionStatement(defineCall));
      }
    } else if (module.isAnonymous) {
      module.astNodes.forEach((function(_this) {
        return function(astNode) {
          if (astNode.callee.name === &#x22;define&#x22; &#x26;&#x26; (astNode[&#x22;arguments&#x22;].length === 1 || (astNode[&#x22;arguments&#x22;].length === 2 &#x26;&#x26; astNode
[&#x22;arguments&#x22;][0].type === &#x22;ArrayExpression&#x22;))) {
            return astNode[&#x22;arguments&#x22;] = [
              b.literal(module.name), b.arrayExpression(module.deps.map(function(dep) {
                return b.literal(dep.name);
              })), _.last(astNode[&#x22;arguments&#x22;])
            ];
          }
        };
      })(this));
    }
    if (module.hasDefine &#x26;&#x26; module.isShimmed) {
      ast.body = [b.expressionStatement(b.callExpression(b.memberExpression(b.functionExpression(null, [], b.blockStatement(ast.
body)), b.identifier(&#x22;call&#x22;), false), [b.thisExpression()]))];
    }
    sourceFile = module.file.clone();
    sourceFile.sourceMap = module.file.sourceMap;
    if (sourceFile.sourceMap) {
      generatedCode = escodegen.generate(ast, {
        comment: options.preserveComments,
        sourceMap: true,
        sourceMapWithCode: true,
        file: sourceFile.sourceMap.file
      });
      sourceFile.contents = new Buffer(generatedCode.code, &#x22;utf8&#x22;);
      vinylSourcemapsApply(sourceFile, generatedCode.map.toJSON());
    } else if (!options.preserveFiles) {
      sourceFile = module.file.clone();
      sourceFile.contents = new Buffer(escodegen.generate(ast, {
        comment: options.preserveComments
      }), &#x22;utf8&#x22;);
    }
    this.push(sourceFile);
    return done();
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.amd-optimize.loader" id="apidoc.module.amd-optimize.loader">module amd-optimize.loader</a></h1>


    <h2>
        <a href="#apidoc.element.amd-optimize.loader.loader" id="apidoc.element.amd-optimize.loader.loader">
        function <span class="apidocSignatureSpan">amd-optimize.</span>loader
        <span class="apidocSignatureSpan">(filenameResolver, pipe)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">loader = function (filenameResolver, pipe) {
  return function(moduleName, callback) {
    var filename, source;
    if (filenameResolver) {
      filename = filenameResolver(moduleName);
    } else {
      filename = moduleName;
    }
    source = vinylFs.src(filename).pipe(through.obj());
    if (pipe) {
      source = source.pipe(pipe());
    }
    firstChunk(source, callback);
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

#### options.loader
WIP. Subject to change.

```js
amdOptimize.src(
  &#x22;index&#x22;,
  loader : amdOptimize.<span class="apidocCodeKeywordSpan">loader</span>(
    // Used for turning a moduleName into a filepath glob.
    function (moduleName) { return &#x22;src/scripts/&#x22; + moduleName + &#x22;.coffee&#x22; },
    // Returns a transform stream.
    function () { return coffee(); }
  )
)
```
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.amd-optimize.parse" id="apidoc.module.amd-optimize.parse">module amd-optimize.parse</a></h1>


    <h2>
        <a href="#apidoc.element.amd-optimize.parse.parse" id="apidoc.element.amd-optimize.parse.parse">
        function <span class="apidocSignatureSpan">amd-optimize.</span>parse
        <span class="apidocSignatureSpan">(config, file, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parse = function (config, file, callback) {
  var ast, comments, definitions, err, tokens;
  try {
    if (config.preserveComments) {
      comments = [];
      tokens = [];
      ast = acorn.parse(file.stringContents, {
        sourceFile: file.relative,
        locations: file.sourceMap != null,
        ranges: true,
        onComment: comments,
        onToken: tokens
      });
      escodegen.attachComments(ast, comments, tokens);
    } else {
      ast = acorn.parse(file.stringContents, {
        sourceFile: file.relative,
        locations: file.sourceMap != null
      });
    }
  } catch (_error) {
    err = _error;
    if (err instanceof SyntaxError) {
      err.filename = file.path;
      err.message += &#x22; in &#x22; + file.path;
    }
    callback(err);
    return;
  }
  file.ast = ast;
  definitions = [];
  walk.ancestor(ast, {
    CallExpression: function(node, state) {
      var defineAncestors, deps, isInsideDefine, moduleName;
      if (node.callee.name === &#x22;define&#x22;) {
        switch (node[&#x22;arguments&#x22;].length) {
          case 1:
            if (node[&#x22;arguments&#x22;][0].type === &#x22;FunctionExpression&#x22; &#x26;&#x26; node[&#x22;arguments&#x22;][0].params.length &#x3e; 0) {
              deps = [&#x27;require&#x27;, &#x27;exports&#x27;, &#x27;module&#x27;];
              walk.simple(node[&#x22;arguments&#x22;][0], {
                CallExpression: function(node) {
                  if (node.callee.name === &#x22;require&#x22; || node.callee.name === &#x22;requirejs&#x22;) {
                    return deps.push(node[&#x22;arguments&#x22;][0].value);
                  }
                }
              });
            }
            break;
          case 2:
            switch (node[&#x22;arguments&#x22;][0].type) {
              case &#x22;Literal&#x22;:
                moduleName = node[&#x22;arguments&#x22;][0].value;
                break;
              case &#x22;ArrayExpression&#x22;:
                deps = valuesFromArrayExpression(node[&#x22;arguments&#x22;][0]);
            }
            break;
          case 3:
            moduleName = node[&#x22;arguments&#x22;][0].value;
            deps = valuesFromArrayExpression(node[&#x22;arguments&#x22;][1]);
        }
        definitions.push({
          method: &#x22;define&#x22;,
          moduleName: moduleName,
          deps: deps != null ? deps : [],
          argumentsLength: node[&#x22;arguments&#x22;].length,
          node: node
        });
        isInsideDefine = true;
      }
      if ((node.callee.name === &#x22;require&#x22; || node.callee.name === &#x22;requirejs&#x22;) &#x26;&#x26; node[&#x22;arguments&#x22;].length &#x3e; 0 &#x26;&#x26; node[&#x22;arguments
&#x22;][0].type === &#x22;ArrayExpression&#x22;) {
        defineAncestors = _.any(state.slice(0, -1), function(ancestorNode) {
          return ancestorNode.type === &#x22;CallExpression&#x22; &#x26;&#x26; (ancestorNode.callee.name === &#x22;define&#x22; || ancestorNode.callee.name === &#x22;
require&#x22; || ancestorNode.callee.name === &#x22;requirejs&#x22;);
        });
        if (config.findNestedDependencies || !defineAncestors) {
          return definitions.push({
            method: &#x22;require&#x22;,
            moduleName: void 0,
            deps: valuesFromArrayExpression(node[&#x22;arguments&#x22;][0]),
            node: node
          });
        }
      }
    }
  });
  callback(null, file, definitions);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  module.exports = parseRequireDefinitions = function(config, file, callback) {
var ast, comments, definitions, err, tokens;
try {
  if (config.preserveComments) {
    comments = [];
    tokens = [];
    ast = acorn.<span class="apidocCodeKeywordSpan">parse</span>(file.stringContents, {
      sourceFile: file.relative,
      locations: file.sourceMap != null,
      ranges: true,
      onComment: comments,
      onToken: tokens
    });
    escodegen.attachComments(ast, comments, tokens);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.amd-optimize.src" id="apidoc.module.amd-optimize.src">module amd-optimize.src</a></h1>


    <h2>
        <a href="#apidoc.element.amd-optimize.src.src" id="apidoc.element.amd-optimize.src.src">
        function <span class="apidocSignatureSpan">amd-optimize.</span>src
        <span class="apidocSignatureSpan">(moduleName, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">src = function (moduleName, options) {
  var source;
  source = rjs(moduleName, options);
  process.nextTick(function() {
    return source.end();
  });
  return source;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```js
var gulp = require(&#x22;gulp&#x22;);
var amdOptimize = require(&#x22;amd-optimize&#x22;);
var concat = require(&#x27;gulp-concat&#x27;);

gulp.task(&#x22;scripts:index&#x22;, function () {

  return gulp.<span class="apidocCodeKeywordSpan">src</span>(&#x22;src/scripts/**/*.js&#x22;)
    // Traces all modules and outputs them in the correct order.
    .pipe(amdOptimize(&#x22;main&#x22;))
    .pipe(concat(&#x22;index.js&#x22;))
    .pipe(gulp.dest(&#x22;dist/scripts&#x22;));

});
```
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.amd-optimize.toString" id="apidoc.module.amd-optimize.toString">module amd-optimize.toString</a></h1>


    <h2>
        <a href="#apidoc.element.amd-optimize.toString.toString" id="apidoc.element.amd-optimize.toString.toString">
        function <span class="apidocSignatureSpan">amd-optimize.</span>toString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function toString() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
  if (file) {
    return callback(null, file);
  } else {
    return callback(new Error(&#x22;No file for module &#x27;&#x22; + moduleName + &#x22;&#x27; found.&#x22;));
  }
}, function(file, callback) {
  file.stringContents = file.contents.<span class="apidocCodeKeywordSpan">toString</span>(&#x22;utf8&#x22;);
  if (isTextFile) {
    file.stringContents = &#x27;define(function(){ return &#x27; + JSON.stringify(file.stringContents) + &#x27;; });&#x27;;
  }
  if (isJsonFile) {
    file.stringContents = &#x27;define(function(){ return JSON.parse(&#x27; + JSON.stringify(file.stringContents) + &#x27;); });&#
x27;;
  }
  module = new Module(moduleName, file);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.amd-optimize.trace" id="apidoc.module.amd-optimize.trace">module amd-optimize.trace</a></h1>


    <h2>
        <a href="#apidoc.element.amd-optimize.trace.trace" id="apidoc.element.amd-optimize.trace.trace">
        function <span class="apidocSignatureSpan">amd-optimize.</span>trace
        <span class="apidocSignatureSpan">(startModuleName, config, allModules, fileLoader, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">trace = function (startModuleName, config, allModules, fileLoader, callback) {
  var emitModule, foundModuleNames, jsonFiles, resolveInlinedModule, resolveModule, resolveModuleFileName, resolveModuleName, resolveModules
, textFiles;
  if (allModules == null) {
    allModules = [];
  }
  foundModuleNames = [];
  textFiles = {};
  jsonFiles = {};
  resolveModuleName = function(moduleName, relativeTo) {
    var eligiblePath, isJson, isText, relativeToFileName, slashIdx;
    if (relativeTo == null) {
      relativeTo = &#x22;&#x22;;
    }
    isText = moduleName.indexOf(&#x27;text!&#x27;) !== -1;
    if (isText) {
      moduleName = moduleName.replace(&#x27;text!&#x27;, &#x27;&#x27;);
    }
    isJson = moduleName.indexOf(&#x27;json!&#x27;) !== -1;
    if (isJson) {
      moduleName = moduleName.replace(&#x27;json!&#x27;, &#x27;&#x27;);
    }
    if (config.paths &#x26;&#x26; !config.paths[moduleName]) {
      slashIdx = moduleName.indexOf(&#x22;/&#x22;);
      if (slashIdx &#x3e; 0) {
        eligiblePath = config.paths[moduleName.substr(0, slashIdx)];
        if (eligiblePath) {
          moduleName = eligiblePath + moduleName.substr(slashIdx);
        }
      }
    }
    relativeToFileName = resolveModuleFileName(relativeTo);
    if (moduleName[0] === &#x22;.&#x22;) {
      moduleName = util.fixModuleName(path.join(path.dirname(relativeToFileName), moduleName));
    }
    if (config.map &#x26;&#x26; config.map[relativeTo] &#x26;&#x26; config.map[relativeTo][moduleName]) {
      moduleName = config.map[relativeTo][moduleName];
    }
    if (isText) {
      textFiles[moduleName] = true;
    }
    if (isJson) {
      jsonFiles[moduleName] = true;
    }
    return moduleName;
  };
  resolveModuleFileName = function(moduleName) {
    if (config.paths &#x26;&#x26; config.paths[moduleName]) {
      moduleName = config.paths[moduleName];
    }
    if (/!|^exports$|^require$|^module$|^empty:/.test(moduleName)) {

    } else {
      return moduleName;
    }
  };
  resolveModules = function(moduleNames, callback) {
    async.mapSeries(moduleNames, resolveModule, callback);
  };
  resolveInlinedModule = function(moduleName, deps, astNode, vinylFile, callback) {
    async.waterfall([
      function(callback) {
        return resolveModules(deps, callback);
      }, function(modules, callback) {
        var module;
        module = new Module(moduleName, vinylFile, _.compact(modules));
        module.hasDefine = true;
        module.isInline = true;
        module.astNodes.push(astNode);
        emitModule(module);
        return callback();
      }
    ], callback);
  };
  resolveModule = function(moduleName, callback) {
    var fileName, isJsonFile, isTextFile, module;
    module = _.detect(allModules, {
      name: moduleName
    });
    if (module) {
      callback(null, module);
      return;
    }
    fileName = resolveModuleFileName(moduleName);
    if (!fileName) {
      module = new Module(moduleName);
      module.isShallow = true;
      callback(null, emitModule(module));
      return;
    }
    if (_.contains(foundModuleNames, moduleName)) {
      callback(new Error(&#x22;Circular dependency detected. Module &#x27;&#x22; + moduleName + &#x22;&#x27; has been processed before.&#x22;));
      return;
    } else {
      foundModuleNames.push(moduleName);
    }
    module = null;
    isTextFile = !!textFiles[moduleName];
    isJsonFile = !!jsonFiles[moduleName];
    async.waterfall([
      function(callback) {
        return fileLoader(fileName, callback, isTextFile || isJsonFile);
      }, function(file, callback) {
        if (arguments.length === 1) {
          callback = file;
          file = null;
        }
        if (file) {
          return callback(null, file);
        } else {
          return callback(new Error(&#x22;No file for module &#x27;&#x22; + moduleName + &#x22;&#x27; found.&#x22;));
        }
      }, function(file, callback) {
        file.stringContents = file.contents.toString(&#x22;utf8&#x22;);
        if (isTextFile) {
          file.stringContents = &#x27;define(function(){ return &#x27; + JSON.stringify(file.stringContents) + &#x27;; });&#x27;;
        }
        if (isJsonFile) {
          file.stringContents = &#x27;define(function(){ return JSON.parse(&#x27; + JSON.stringify(file.stringContents) + &#x27;); });&#x27;;
        }
        module = new ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.amd-optimize.util" id="apidoc.module.amd-optimize.util">module amd-optimize.util</a></h1>


    <h2>
        <a href="#apidoc.element.amd-optimize.util.fixModuleName" id="apidoc.element.amd-optimize.util.fixModuleName">
        function <span class="apidocSignatureSpan">amd-optimize.util.</span>fixModuleName
        <span class="apidocSignatureSpan">(moduleName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fixModuleName = function (moduleName) {
  return moduleName.replace(/\\/g, &#x27;/&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
util = require(&#x22;./util&#x22;);

Module = (function() {
  function Module(name, file1, deps1) {
    this.name = name;
    this.file = file1;
    this.deps = deps1 != null ? deps1 : [];
    this.name = util.<span class="apidocCodeKeywordSpan">fixModuleName</span>(this.name);
    this.isShallow = false;
    this.isShimmed = false;
    this.isAnonymous = false;
    this.isInline = false;
    this.hasDefine = false;
    this.astNodes = [];
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amd-optimize.util.logger" id="apidoc.element.amd-optimize.util.logger">
        function <span class="apidocSignatureSpan">amd-optimize.util.</span>logger
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">logger = function () {
  return through.obj(function(file, enc, callback) {
    console.log(&#x22;&#x3e;&#x3e;&#x22;, path.relative(process.cwd(), file.path));
    return callback(null, file);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amd-optimize.util.printTree" id="apidoc.element.amd-optimize.util.printTree">
        function <span class="apidocSignatureSpan">amd-optimize.util.</span>printTree
        <span class="apidocSignatureSpan">(currentModule, prefix)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">printTree = function (currentModule, prefix) {
  var depPrefix;
  if (prefix == null) {
    prefix = &#x22;&#x22;;
  }
  console.log(prefix, currentModule.name, &#x22;(&#x22; + (path.relative(process.cwd(), currentModule.file.relative)) + &#x22;)&#x22;);
  depPrefix = prefix.replace(&#x22;├&#x22;, &#x22;|&#x22;).replace(&#x22;└&#x22;, &#x22; &#x22;).replace(/─/g, &#x22; &#x22;);
  return currentModule.deps.forEach(function(depModule, i) {
    if (i + 1 &#x3c; currentModule.deps.length) {
      return printTree(depModule, depPrefix + &#x22; ├──&#x22;);
    } else {
      return printTree(depModule, depPrefix + &#x22; └──&#x22;);
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
