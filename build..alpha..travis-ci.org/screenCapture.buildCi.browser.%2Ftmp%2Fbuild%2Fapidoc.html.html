<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="https://github.com/scalableminds/amd-optimize#readme">amd-optimize (v0.6.1)</a>
</h1>
<h4>An AMD (i.e. RequireJS) optimizer that's stream-friendly. Made for gulp. (WIP)</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.amd-optimize">module amd-optimize</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amd-optimize.amd-optimize">
            function <span class="apidocSignatureSpan"></span>amd-optimize
            <span class="apidocSignatureSpan">(entryModuleName, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amd-optimize.export">
            function <span class="apidocSignatureSpan">amd-optimize.</span>export
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amd-optimize.loader">
            function <span class="apidocSignatureSpan">amd-optimize.</span>loader
            <span class="apidocSignatureSpan">(filenameResolver, pipe)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amd-optimize.parse">
            function <span class="apidocSignatureSpan">amd-optimize.</span>parse
            <span class="apidocSignatureSpan">(config, file, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amd-optimize.src">
            function <span class="apidocSignatureSpan">amd-optimize.</span>src
            <span class="apidocSignatureSpan">(moduleName, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amd-optimize.toString">
            function <span class="apidocSignatureSpan">amd-optimize.</span>toString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amd-optimize.trace">
            function <span class="apidocSignatureSpan">amd-optimize.</span>trace
            <span class="apidocSignatureSpan">(startModuleName, config, allModules, fileLoader, callback)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">amd-optimize.</span>util</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.amd-optimize.export">module amd-optimize.export</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amd-optimize.export.export">
            function <span class="apidocSignatureSpan">amd-optimize.</span>export
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.amd-optimize.loader">module amd-optimize.loader</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amd-optimize.loader.loader">
            function <span class="apidocSignatureSpan">amd-optimize.</span>loader
            <span class="apidocSignatureSpan">(filenameResolver, pipe)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.amd-optimize.parse">module amd-optimize.parse</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amd-optimize.parse.parse">
            function <span class="apidocSignatureSpan">amd-optimize.</span>parse
            <span class="apidocSignatureSpan">(config, file, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.amd-optimize.src">module amd-optimize.src</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amd-optimize.src.src">
            function <span class="apidocSignatureSpan">amd-optimize.</span>src
            <span class="apidocSignatureSpan">(moduleName, options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.amd-optimize.toString">module amd-optimize.toString</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amd-optimize.toString.toString">
            function <span class="apidocSignatureSpan">amd-optimize.</span>toString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.amd-optimize.trace">module amd-optimize.trace</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amd-optimize.trace.trace">
            function <span class="apidocSignatureSpan">amd-optimize.</span>trace
            <span class="apidocSignatureSpan">(startModuleName, config, allModules, fileLoader, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.amd-optimize.util">module amd-optimize.util</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amd-optimize.util.fixModuleName">
            function <span class="apidocSignatureSpan">amd-optimize.util.</span>fixModuleName
            <span class="apidocSignatureSpan">(moduleName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amd-optimize.util.logger">
            function <span class="apidocSignatureSpan">amd-optimize.util.</span>logger
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.amd-optimize.util.printTree">
            function <span class="apidocSignatureSpan">amd-optimize.util.</span>printTree
            <span class="apidocSignatureSpan">(currentModule, prefix)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.amd-optimize" id="apidoc.module.amd-optimize">module amd-optimize</a></h1>


    <h2>
        <a href="#apidoc.element.amd-optimize.amd-optimize" id="apidoc.element.amd-optimize.amd-optimize">
        function <span class="apidocSignatureSpan"></span>amd-optimize
        <span class="apidocSignatureSpan">(entryModuleName, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">amd-optimize = function (entryModuleName, options) {
  var configFileStream, fileBuffer, mainStream;
  if (options == null) {
    options = {};
  }
  options = _.defaults(options, {
    baseUrl: "",
    configFile: null,
    exclude: [],
    excludeShallow: [],
    findNestedDependencies: false,
    loader: null,
    preserveComments: false,
    preserveFiles: false
  });
  if (_.isString(options.exclude)) {
    options.exclude = [options.exclude];
  }
  if (_.isString(options.excludeShallow)) {
    options.excludeShallow = [options.excludeShallow];
  }
  if (_.isString(options.configFile) || _.isArray(options.configFile)) {
    configFileStream = vinylFs.src(options.configFile);
  } else if (_.isObject(options.configFile)) {
    configFileStream = options.configFile;
  }
  fileBuffer = [];
  mainStream = through.obj(function(file, enc, done) {
    fileBuffer.push(file);
    return done();
  }, function(done) {
    return async.waterfall([
      function(callback) {
        if (configFileStream) {
          return configFileStream.pipe(through.obj(function(file, enc, done) {
            options = mergeOptionsFile(file, options);
            return done();
          }, function() {
            return callback();
          }));
        } else {
          return callback();
        }
      }, function(callback) {
        return trace(entryModuleName, options, null, defaultLoader(fileBuffer, options), callback);
      }, function(module, callback) {
        return callback(null, collectModules(module));
      }, function(modules, callback) {
        if (_.isArray(options.exclude)) {
          return async.map(options.exclude, function(moduleName, callback) {
            return trace(moduleName, options, null, defaultLoader(fileBuffer, options), callback);
          }, function(err, excludedModules) {
            if (err) {
              return callback(err);
            } else {
              return callback(null, modules, _(excludedModules).map(function(module) {
                return collectModules(module);
              }).flatten().pluck("name").unique().value());
            }
          });
        } else {
          return callback(null, modules, []);
        }
      }, function(modules, excludedModuleNames, callback) {
        var exportStream;
        modules = _.reject(modules, function(module) {
          return _.contains(excludedModuleNames, module.name) || _.contains(options.excludeShallow, module.name);
        });
        exportStream = exportModule(options);
        exportStream.on("data", function(file) {
          return mainStream.push(file);
        }).on("end", function() {
          return callback();
        }).on("error", callback);
        modules.forEach(exportStream.write.bind(exportStream));
        return exportStream.end();
      }
    ], done);
  });
  return mainStream;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amd-optimize.export" id="apidoc.element.amd-optimize.export">
        function <span class="apidocSignatureSpan">amd-optimize.</span>export
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">export = function (options) {
  if (options == null) {
    options = {};
  }
  options = _.defaults(options, {
    wrapShim: true
  });
  return through.obj(function(module, enc, done) {
    var ast, defineBody, defineCall, defineReturnStatement, generatedCode, sourceFile;
    if (module.isShallow) {
      done();
      return;
    }
    ast = module.file.ast;
    delete module.file.ast;
    if (!module.hasDefine) {
      defineReturnStatement = b.returnStatement(module.exports ? b.identifier(module.exports) : null);
      if (options.wrapShim &amp;&amp; module.isShimmed) {
        defineBody = ast.body.concat([defineReturnStatement]);
      } else {
        defineBody = [defineReturnStatement];
      }
      defineCall = b.callExpression(b.identifier("define"), [
        b.literal(module.name), b.arrayExpression(module.deps.map(function(dep) {
          return b.literal(dep.name);
        })), b.functionExpression(null, [], b.blockStatement(defineBody))
      ]);
      if (options.wrapShim &amp;&amp; module.isShimmed) {
        ast.body = [b.expressionStatement(defineCall)];
      } else {
        ast.body.push(b.expressionStatement(defineCall));
      }
    } else if (module.isAnonymous) {
      module.astNodes.forEach((function(_this) {
        return function(astNode) {
          if (astNode.callee.name === "define" &amp;&amp; (astNode["arguments"].length === 1 || (astNode["arguments"].length === 2 &amp;&amp; astNode
["arguments"][0].type === "ArrayExpression"))) {
            return astNode["arguments"] = [
              b.literal(module.name), b.arrayExpression(module.deps.map(function(dep) {
                return b.literal(dep.name);
              })), _.last(astNode["arguments"])
            ];
          }
        };
      })(this));
    }
    if (module.hasDefine &amp;&amp; module.isShimmed) {
      ast.body = [b.expressionStatement(b.callExpression(b.memberExpression(b.functionExpression(null, [], b.blockStatement(ast.
body)), b.identifier("call"), false), [b.thisExpression()]))];
    }
    sourceFile = module.file.clone();
    sourceFile.sourceMap = module.file.sourceMap;
    if (sourceFile.sourceMap) {
      generatedCode = escodegen.generate(ast, {
        comment: options.preserveComments,
        sourceMap: true,
        sourceMapWithCode: true,
        file: sourceFile.sourceMap.file
      });
      sourceFile.contents = new Buffer(generatedCode.code, "utf8");
      vinylSourcemapsApply(sourceFile, generatedCode.map.toJSON());
    } else if (!options.preserveFiles) {
      sourceFile = module.file.clone();
      sourceFile.contents = new Buffer(escodegen.generate(ast, {
        comment: options.preserveComments
      }), "utf8");
    }
    this.push(sourceFile);
    return done();
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amd-optimize.loader" id="apidoc.element.amd-optimize.loader">
        function <span class="apidocSignatureSpan">amd-optimize.</span>loader
        <span class="apidocSignatureSpan">(filenameResolver, pipe)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">loader = function (filenameResolver, pipe) {
  return function(moduleName, callback) {
    var filename, source;
    if (filenameResolver) {
      filename = filenameResolver(moduleName);
    } else {
      filename = moduleName;
    }
    source = vinylFs.src(filename).pipe(through.obj());
    if (pipe) {
      source = source.pipe(pipe());
    }
    firstChunk(source, callback);
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

#### options.loader
WIP. Subject to change.

```js
amdOptimize.src(
  "index",
  loader : amdOptimize.<span class="apidocCodeKeywordSpan">loader</span>(
    // Used for turning a moduleName into a filepath glob.
    function (moduleName) { return "src/scripts/" + moduleName + ".coffee" },
    // Returns a transform stream.
    function () { return coffee(); }
  )
)
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amd-optimize.parse" id="apidoc.element.amd-optimize.parse">
        function <span class="apidocSignatureSpan">amd-optimize.</span>parse
        <span class="apidocSignatureSpan">(config, file, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parse = function (config, file, callback) {
  var ast, comments, definitions, err, tokens;
  try {
    if (config.preserveComments) {
      comments = [];
      tokens = [];
      ast = acorn.parse(file.stringContents, {
        sourceFile: file.relative,
        locations: file.sourceMap != null,
        ranges: true,
        onComment: comments,
        onToken: tokens
      });
      escodegen.attachComments(ast, comments, tokens);
    } else {
      ast = acorn.parse(file.stringContents, {
        sourceFile: file.relative,
        locations: file.sourceMap != null
      });
    }
  } catch (_error) {
    err = _error;
    if (err instanceof SyntaxError) {
      err.filename = file.path;
      err.message += " in " + file.path;
    }
    callback(err);
    return;
  }
  file.ast = ast;
  definitions = [];
  walk.ancestor(ast, {
    CallExpression: function(node, state) {
      var defineAncestors, deps, isInsideDefine, moduleName;
      if (node.callee.name === "define") {
        switch (node["arguments"].length) {
          case 1:
            if (node["arguments"][0].type === "FunctionExpression" &amp;&amp; node["arguments"][0].params.length &gt; 0) {
              deps = ['require', 'exports', 'module'];
              walk.simple(node["arguments"][0], {
                CallExpression: function(node) {
                  if (node.callee.name === "require" || node.callee.name === "requirejs") {
                    return deps.push(node["arguments"][0].value);
                  }
                }
              });
            }
            break;
          case 2:
            switch (node["arguments"][0].type) {
              case "Literal":
                moduleName = node["arguments"][0].value;
                break;
              case "ArrayExpression":
                deps = valuesFromArrayExpression(node["arguments"][0]);
            }
            break;
          case 3:
            moduleName = node["arguments"][0].value;
            deps = valuesFromArrayExpression(node["arguments"][1]);
        }
        definitions.push({
          method: "define",
          moduleName: moduleName,
          deps: deps != null ? deps : [],
          argumentsLength: node["arguments"].length,
          node: node
        });
        isInsideDefine = true;
      }
      if ((node.callee.name === "require" || node.callee.name === "requirejs") &amp;&amp; node["arguments"].length &gt; 0 &amp;&amp; node["arguments
"][0].type === "ArrayExpression") {
        defineAncestors = _.any(state.slice(0, -1), function(ancestorNode) {
          return ancestorNode.type === "CallExpression" &amp;&amp; (ancestorNode.callee.name === "define" || ancestorNode.callee.name === "
require" || ancestorNode.callee.name === "requirejs");
        });
        if (config.findNestedDependencies || !defineAncestors) {
          return definitions.push({
            method: "require",
            moduleName: void 0,
            deps: valuesFromArrayExpression(node["arguments"][0]),
            node: node
          });
        }
      }
    }
  });
  callback(null, file, definitions);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  module.exports = parseRequireDefinitions = function(config, file, callback) {
var ast, comments, definitions, err, tokens;
try {
  if (config.preserveComments) {
    comments = [];
    tokens = [];
    ast = acorn.<span class="apidocCodeKeywordSpan">parse</span>(file.stringContents, {
      sourceFile: file.relative,
      locations: file.sourceMap != null,
      ranges: true,
      onComment: comments,
      onToken: tokens
    });
    escodegen.attachComments(ast, comments, tokens);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amd-optimize.src" id="apidoc.element.amd-optimize.src">
        function <span class="apidocSignatureSpan">amd-optimize.</span>src
        <span class="apidocSignatureSpan">(moduleName, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">src = function (moduleName, options) {
  var source;
  source = rjs(moduleName, options);
  process.nextTick(function() {
    return source.end();
  });
  return source;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```js
var gulp = require("gulp");
var amdOptimize = require("amd-optimize");
var concat = require('gulp-concat');

gulp.task("scripts:index", function () {

  return gulp.<span class="apidocCodeKeywordSpan">src</span>("src/scripts/**/*.js")
    // Traces all modules and outputs them in the correct order.
    .pipe(amdOptimize("main"))
    .pipe(concat("index.js"))
    .pipe(gulp.dest("dist/scripts"));

});
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amd-optimize.toString" id="apidoc.element.amd-optimize.toString">
        function <span class="apidocSignatureSpan">amd-optimize.</span>toString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function () {
    return text;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
  if (file) {
    return callback(null, file);
  } else {
    return callback(new Error("No file for module '" + moduleName + "' found."));
  }
}, function(file, callback) {
  file.stringContents = file.contents.<span class="apidocCodeKeywordSpan">toString</span>("utf8");
  if (isTextFile) {
    file.stringContents = 'define(function(){ return ' + JSON.stringify(file.stringContents) + '; });';
  }
  if (isJsonFile) {
    file.stringContents = 'define(function(){ return JSON.parse(' + JSON.stringify(file.stringContents) + '); });&amp;#
x27;;
  }
  module = new Module(moduleName, file);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amd-optimize.trace" id="apidoc.element.amd-optimize.trace">
        function <span class="apidocSignatureSpan">amd-optimize.</span>trace
        <span class="apidocSignatureSpan">(startModuleName, config, allModules, fileLoader, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">trace = function (startModuleName, config, allModules, fileLoader, callback) {
  var emitModule, foundModuleNames, jsonFiles, resolveInlinedModule, resolveModule, resolveModuleFileName, resolveModuleName, resolveModules
, textFiles;
  if (allModules == null) {
    allModules = [];
  }
  foundModuleNames = [];
  textFiles = {};
  jsonFiles = {};
  resolveModuleName = function(moduleName, relativeTo) {
    var eligiblePath, isJson, isText, relativeToFileName, slashIdx;
    if (relativeTo == null) {
      relativeTo = "";
    }
    isText = moduleName.indexOf('text!') !== -1;
    if (isText) {
      moduleName = moduleName.replace('text!', '');
    }
    isJson = moduleName.indexOf('json!') !== -1;
    if (isJson) {
      moduleName = moduleName.replace('json!', '');
    }
    if (config.paths &amp;&amp; !config.paths[moduleName]) {
      slashIdx = moduleName.indexOf("/");
      if (slashIdx &gt; 0) {
        eligiblePath = config.paths[moduleName.substr(0, slashIdx)];
        if (eligiblePath) {
          moduleName = eligiblePath + moduleName.substr(slashIdx);
        }
      }
    }
    relativeToFileName = resolveModuleFileName(relativeTo);
    if (moduleName[0] === ".") {
      moduleName = util.fixModuleName(path.join(path.dirname(relativeToFileName), moduleName));
    }
    if (config.map &amp;&amp; config.map[relativeTo] &amp;&amp; config.map[relativeTo][moduleName]) {
      moduleName = config.map[relativeTo][moduleName];
    }
    if (isText) {
      textFiles[moduleName] = true;
    }
    if (isJson) {
      jsonFiles[moduleName] = true;
    }
    return moduleName;
  };
  resolveModuleFileName = function(moduleName) {
    if (config.paths &amp;&amp; config.paths[moduleName]) {
      moduleName = config.paths[moduleName];
    }
    if (/!|^exports$|^require$|^module$|^empty:/.test(moduleName)) {

    } else {
      return moduleName;
    }
  };
  resolveModules = function(moduleNames, callback) {
    async.mapSeries(moduleNames, resolveModule, callback);
  };
  resolveInlinedModule = function(moduleName, deps, astNode, vinylFile, callback) {
    async.waterfall([
      function(callback) {
        return resolveModules(deps, callback);
      }, function(modules, callback) {
        var module;
        module = new Module(moduleName, vinylFile, _.compact(modules));
        module.hasDefine = true;
        module.isInline = true;
        module.astNodes.push(astNode);
        emitModule(module);
        return callback();
      }
    ], callback);
  };
  resolveModule = function(moduleName, callback) {
    var fileName, isJsonFile, isTextFile, module;
    module = _.detect(allModules, {
      name: moduleName
    });
    if (module) {
      callback(null, module);
      return;
    }
    fileName = resolveModuleFileName(moduleName);
    if (!fileName) {
      module = new Module(moduleName);
      module.isShallow = true;
      callback(null, emitModule(module));
      return;
    }
    if (_.contains(foundModuleNames, moduleName)) {
      callback(new Error("Circular dependency detected. Module '" + moduleName + "' has been processed before."));
      return;
    } else {
      foundModuleNames.push(moduleName);
    }
    module = null;
    isTextFile = !!textFiles[moduleName];
    isJsonFile = !!jsonFiles[moduleName];
    async.waterfall([
      function(callback) {
        return fileLoader(fileName, callback, isTextFile || isJsonFile);
      }, function(file, callback) {
        if (arguments.length === 1) {
          callback = file;
          file = null;
        }
        if (file) {
          return callback(null, file);
        } else {
          return callback(new Error("No file for module '" + moduleName + "' found."));
        }
      }, function(file, callback) {
        file.stringContents = file.contents.toString("utf8");
        if (isTextFile) {
          file.stringContents = 'define(function(){ return ' + JSON.stringify(file.stringContents) + '; });';
        }
        if (isJsonFile) {
          file.stringContents = 'define(function(){ return JSON.parse(' + JSON.stringify(file.stringContents) + '); });';
        }
        module = new ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.amd-optimize.export" id="apidoc.module.amd-optimize.export">module amd-optimize.export</a></h1>


    <h2>
        <a href="#apidoc.element.amd-optimize.export.export" id="apidoc.element.amd-optimize.export.export">
        function <span class="apidocSignatureSpan">amd-optimize.</span>export
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">export = function (options) {
  if (options == null) {
    options = {};
  }
  options = _.defaults(options, {
    wrapShim: true
  });
  return through.obj(function(module, enc, done) {
    var ast, defineBody, defineCall, defineReturnStatement, generatedCode, sourceFile;
    if (module.isShallow) {
      done();
      return;
    }
    ast = module.file.ast;
    delete module.file.ast;
    if (!module.hasDefine) {
      defineReturnStatement = b.returnStatement(module.exports ? b.identifier(module.exports) : null);
      if (options.wrapShim &amp;&amp; module.isShimmed) {
        defineBody = ast.body.concat([defineReturnStatement]);
      } else {
        defineBody = [defineReturnStatement];
      }
      defineCall = b.callExpression(b.identifier("define"), [
        b.literal(module.name), b.arrayExpression(module.deps.map(function(dep) {
          return b.literal(dep.name);
        })), b.functionExpression(null, [], b.blockStatement(defineBody))
      ]);
      if (options.wrapShim &amp;&amp; module.isShimmed) {
        ast.body = [b.expressionStatement(defineCall)];
      } else {
        ast.body.push(b.expressionStatement(defineCall));
      }
    } else if (module.isAnonymous) {
      module.astNodes.forEach((function(_this) {
        return function(astNode) {
          if (astNode.callee.name === "define" &amp;&amp; (astNode["arguments"].length === 1 || (astNode["arguments"].length === 2 &amp;&amp; astNode
["arguments"][0].type === "ArrayExpression"))) {
            return astNode["arguments"] = [
              b.literal(module.name), b.arrayExpression(module.deps.map(function(dep) {
                return b.literal(dep.name);
              })), _.last(astNode["arguments"])
            ];
          }
        };
      })(this));
    }
    if (module.hasDefine &amp;&amp; module.isShimmed) {
      ast.body = [b.expressionStatement(b.callExpression(b.memberExpression(b.functionExpression(null, [], b.blockStatement(ast.
body)), b.identifier("call"), false), [b.thisExpression()]))];
    }
    sourceFile = module.file.clone();
    sourceFile.sourceMap = module.file.sourceMap;
    if (sourceFile.sourceMap) {
      generatedCode = escodegen.generate(ast, {
        comment: options.preserveComments,
        sourceMap: true,
        sourceMapWithCode: true,
        file: sourceFile.sourceMap.file
      });
      sourceFile.contents = new Buffer(generatedCode.code, "utf8");
      vinylSourcemapsApply(sourceFile, generatedCode.map.toJSON());
    } else if (!options.preserveFiles) {
      sourceFile = module.file.clone();
      sourceFile.contents = new Buffer(escodegen.generate(ast, {
        comment: options.preserveComments
      }), "utf8");
    }
    this.push(sourceFile);
    return done();
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.amd-optimize.loader" id="apidoc.module.amd-optimize.loader">module amd-optimize.loader</a></h1>


    <h2>
        <a href="#apidoc.element.amd-optimize.loader.loader" id="apidoc.element.amd-optimize.loader.loader">
        function <span class="apidocSignatureSpan">amd-optimize.</span>loader
        <span class="apidocSignatureSpan">(filenameResolver, pipe)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">loader = function (filenameResolver, pipe) {
  return function(moduleName, callback) {
    var filename, source;
    if (filenameResolver) {
      filename = filenameResolver(moduleName);
    } else {
      filename = moduleName;
    }
    source = vinylFs.src(filename).pipe(through.obj());
    if (pipe) {
      source = source.pipe(pipe());
    }
    firstChunk(source, callback);
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

#### options.loader
WIP. Subject to change.

```js
amdOptimize.src(
  "index",
  loader : amdOptimize.<span class="apidocCodeKeywordSpan">loader</span>(
    // Used for turning a moduleName into a filepath glob.
    function (moduleName) { return "src/scripts/" + moduleName + ".coffee" },
    // Returns a transform stream.
    function () { return coffee(); }
  )
)
```
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.amd-optimize.parse" id="apidoc.module.amd-optimize.parse">module amd-optimize.parse</a></h1>


    <h2>
        <a href="#apidoc.element.amd-optimize.parse.parse" id="apidoc.element.amd-optimize.parse.parse">
        function <span class="apidocSignatureSpan">amd-optimize.</span>parse
        <span class="apidocSignatureSpan">(config, file, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parse = function (config, file, callback) {
  var ast, comments, definitions, err, tokens;
  try {
    if (config.preserveComments) {
      comments = [];
      tokens = [];
      ast = acorn.parse(file.stringContents, {
        sourceFile: file.relative,
        locations: file.sourceMap != null,
        ranges: true,
        onComment: comments,
        onToken: tokens
      });
      escodegen.attachComments(ast, comments, tokens);
    } else {
      ast = acorn.parse(file.stringContents, {
        sourceFile: file.relative,
        locations: file.sourceMap != null
      });
    }
  } catch (_error) {
    err = _error;
    if (err instanceof SyntaxError) {
      err.filename = file.path;
      err.message += " in " + file.path;
    }
    callback(err);
    return;
  }
  file.ast = ast;
  definitions = [];
  walk.ancestor(ast, {
    CallExpression: function(node, state) {
      var defineAncestors, deps, isInsideDefine, moduleName;
      if (node.callee.name === "define") {
        switch (node["arguments"].length) {
          case 1:
            if (node["arguments"][0].type === "FunctionExpression" &amp;&amp; node["arguments"][0].params.length &gt; 0) {
              deps = ['require', 'exports', 'module'];
              walk.simple(node["arguments"][0], {
                CallExpression: function(node) {
                  if (node.callee.name === "require" || node.callee.name === "requirejs") {
                    return deps.push(node["arguments"][0].value);
                  }
                }
              });
            }
            break;
          case 2:
            switch (node["arguments"][0].type) {
              case "Literal":
                moduleName = node["arguments"][0].value;
                break;
              case "ArrayExpression":
                deps = valuesFromArrayExpression(node["arguments"][0]);
            }
            break;
          case 3:
            moduleName = node["arguments"][0].value;
            deps = valuesFromArrayExpression(node["arguments"][1]);
        }
        definitions.push({
          method: "define",
          moduleName: moduleName,
          deps: deps != null ? deps : [],
          argumentsLength: node["arguments"].length,
          node: node
        });
        isInsideDefine = true;
      }
      if ((node.callee.name === "require" || node.callee.name === "requirejs") &amp;&amp; node["arguments"].length &gt; 0 &amp;&amp; node["arguments
"][0].type === "ArrayExpression") {
        defineAncestors = _.any(state.slice(0, -1), function(ancestorNode) {
          return ancestorNode.type === "CallExpression" &amp;&amp; (ancestorNode.callee.name === "define" || ancestorNode.callee.name === "
require" || ancestorNode.callee.name === "requirejs");
        });
        if (config.findNestedDependencies || !defineAncestors) {
          return definitions.push({
            method: "require",
            moduleName: void 0,
            deps: valuesFromArrayExpression(node["arguments"][0]),
            node: node
          });
        }
      }
    }
  });
  callback(null, file, definitions);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  module.exports = parseRequireDefinitions = function(config, file, callback) {
var ast, comments, definitions, err, tokens;
try {
  if (config.preserveComments) {
    comments = [];
    tokens = [];
    ast = acorn.<span class="apidocCodeKeywordSpan">parse</span>(file.stringContents, {
      sourceFile: file.relative,
      locations: file.sourceMap != null,
      ranges: true,
      onComment: comments,
      onToken: tokens
    });
    escodegen.attachComments(ast, comments, tokens);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.amd-optimize.src" id="apidoc.module.amd-optimize.src">module amd-optimize.src</a></h1>


    <h2>
        <a href="#apidoc.element.amd-optimize.src.src" id="apidoc.element.amd-optimize.src.src">
        function <span class="apidocSignatureSpan">amd-optimize.</span>src
        <span class="apidocSignatureSpan">(moduleName, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">src = function (moduleName, options) {
  var source;
  source = rjs(moduleName, options);
  process.nextTick(function() {
    return source.end();
  });
  return source;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```js
var gulp = require("gulp");
var amdOptimize = require("amd-optimize");
var concat = require('gulp-concat');

gulp.task("scripts:index", function () {

  return gulp.<span class="apidocCodeKeywordSpan">src</span>("src/scripts/**/*.js")
    // Traces all modules and outputs them in the correct order.
    .pipe(amdOptimize("main"))
    .pipe(concat("index.js"))
    .pipe(gulp.dest("dist/scripts"));

});
```
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.amd-optimize.toString" id="apidoc.module.amd-optimize.toString">module amd-optimize.toString</a></h1>


    <h2>
        <a href="#apidoc.element.amd-optimize.toString.toString" id="apidoc.element.amd-optimize.toString.toString">
        function <span class="apidocSignatureSpan">amd-optimize.</span>toString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function toString() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
  if (file) {
    return callback(null, file);
  } else {
    return callback(new Error("No file for module '" + moduleName + "' found."));
  }
}, function(file, callback) {
  file.stringContents = file.contents.<span class="apidocCodeKeywordSpan">toString</span>("utf8");
  if (isTextFile) {
    file.stringContents = 'define(function(){ return ' + JSON.stringify(file.stringContents) + '; });';
  }
  if (isJsonFile) {
    file.stringContents = 'define(function(){ return JSON.parse(' + JSON.stringify(file.stringContents) + '); });&amp;#
x27;;
  }
  module = new Module(moduleName, file);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.amd-optimize.trace" id="apidoc.module.amd-optimize.trace">module amd-optimize.trace</a></h1>


    <h2>
        <a href="#apidoc.element.amd-optimize.trace.trace" id="apidoc.element.amd-optimize.trace.trace">
        function <span class="apidocSignatureSpan">amd-optimize.</span>trace
        <span class="apidocSignatureSpan">(startModuleName, config, allModules, fileLoader, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">trace = function (startModuleName, config, allModules, fileLoader, callback) {
  var emitModule, foundModuleNames, jsonFiles, resolveInlinedModule, resolveModule, resolveModuleFileName, resolveModuleName, resolveModules
, textFiles;
  if (allModules == null) {
    allModules = [];
  }
  foundModuleNames = [];
  textFiles = {};
  jsonFiles = {};
  resolveModuleName = function(moduleName, relativeTo) {
    var eligiblePath, isJson, isText, relativeToFileName, slashIdx;
    if (relativeTo == null) {
      relativeTo = "";
    }
    isText = moduleName.indexOf('text!') !== -1;
    if (isText) {
      moduleName = moduleName.replace('text!', '');
    }
    isJson = moduleName.indexOf('json!') !== -1;
    if (isJson) {
      moduleName = moduleName.replace('json!', '');
    }
    if (config.paths &amp;&amp; !config.paths[moduleName]) {
      slashIdx = moduleName.indexOf("/");
      if (slashIdx &gt; 0) {
        eligiblePath = config.paths[moduleName.substr(0, slashIdx)];
        if (eligiblePath) {
          moduleName = eligiblePath + moduleName.substr(slashIdx);
        }
      }
    }
    relativeToFileName = resolveModuleFileName(relativeTo);
    if (moduleName[0] === ".") {
      moduleName = util.fixModuleName(path.join(path.dirname(relativeToFileName), moduleName));
    }
    if (config.map &amp;&amp; config.map[relativeTo] &amp;&amp; config.map[relativeTo][moduleName]) {
      moduleName = config.map[relativeTo][moduleName];
    }
    if (isText) {
      textFiles[moduleName] = true;
    }
    if (isJson) {
      jsonFiles[moduleName] = true;
    }
    return moduleName;
  };
  resolveModuleFileName = function(moduleName) {
    if (config.paths &amp;&amp; config.paths[moduleName]) {
      moduleName = config.paths[moduleName];
    }
    if (/!|^exports$|^require$|^module$|^empty:/.test(moduleName)) {

    } else {
      return moduleName;
    }
  };
  resolveModules = function(moduleNames, callback) {
    async.mapSeries(moduleNames, resolveModule, callback);
  };
  resolveInlinedModule = function(moduleName, deps, astNode, vinylFile, callback) {
    async.waterfall([
      function(callback) {
        return resolveModules(deps, callback);
      }, function(modules, callback) {
        var module;
        module = new Module(moduleName, vinylFile, _.compact(modules));
        module.hasDefine = true;
        module.isInline = true;
        module.astNodes.push(astNode);
        emitModule(module);
        return callback();
      }
    ], callback);
  };
  resolveModule = function(moduleName, callback) {
    var fileName, isJsonFile, isTextFile, module;
    module = _.detect(allModules, {
      name: moduleName
    });
    if (module) {
      callback(null, module);
      return;
    }
    fileName = resolveModuleFileName(moduleName);
    if (!fileName) {
      module = new Module(moduleName);
      module.isShallow = true;
      callback(null, emitModule(module));
      return;
    }
    if (_.contains(foundModuleNames, moduleName)) {
      callback(new Error("Circular dependency detected. Module '" + moduleName + "' has been processed before."));
      return;
    } else {
      foundModuleNames.push(moduleName);
    }
    module = null;
    isTextFile = !!textFiles[moduleName];
    isJsonFile = !!jsonFiles[moduleName];
    async.waterfall([
      function(callback) {
        return fileLoader(fileName, callback, isTextFile || isJsonFile);
      }, function(file, callback) {
        if (arguments.length === 1) {
          callback = file;
          file = null;
        }
        if (file) {
          return callback(null, file);
        } else {
          return callback(new Error("No file for module '" + moduleName + "' found."));
        }
      }, function(file, callback) {
        file.stringContents = file.contents.toString("utf8");
        if (isTextFile) {
          file.stringContents = 'define(function(){ return ' + JSON.stringify(file.stringContents) + '; });';
        }
        if (isJsonFile) {
          file.stringContents = 'define(function(){ return JSON.parse(' + JSON.stringify(file.stringContents) + '); });';
        }
        module = new ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.amd-optimize.util" id="apidoc.module.amd-optimize.util">module amd-optimize.util</a></h1>


    <h2>
        <a href="#apidoc.element.amd-optimize.util.fixModuleName" id="apidoc.element.amd-optimize.util.fixModuleName">
        function <span class="apidocSignatureSpan">amd-optimize.util.</span>fixModuleName
        <span class="apidocSignatureSpan">(moduleName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fixModuleName = function (moduleName) {
  return moduleName.replace(/\\/g, '/');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
util = require("./util");

Module = (function() {
  function Module(name, file1, deps1) {
    this.name = name;
    this.file = file1;
    this.deps = deps1 != null ? deps1 : [];
    this.name = util.<span class="apidocCodeKeywordSpan">fixModuleName</span>(this.name);
    this.isShallow = false;
    this.isShimmed = false;
    this.isAnonymous = false;
    this.isInline = false;
    this.hasDefine = false;
    this.astNodes = [];
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amd-optimize.util.logger" id="apidoc.element.amd-optimize.util.logger">
        function <span class="apidocSignatureSpan">amd-optimize.util.</span>logger
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">logger = function () {
  return through.obj(function(file, enc, callback) {
    console.log("&gt;&gt;", path.relative(process.cwd(), file.path));
    return callback(null, file);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.amd-optimize.util.printTree" id="apidoc.element.amd-optimize.util.printTree">
        function <span class="apidocSignatureSpan">amd-optimize.util.</span>printTree
        <span class="apidocSignatureSpan">(currentModule, prefix)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">printTree = function (currentModule, prefix) {
  var depPrefix;
  if (prefix == null) {
    prefix = "";
  }
  console.log(prefix, currentModule.name, "(" + (path.relative(process.cwd(), currentModule.file.relative)) + ")");
  depPrefix = prefix.replace("â”œ", "|").replace("â””", " ").replace(/â”€/g, " ");
  return currentModule.deps.forEach(function(depModule, i) {
    if (i + 1 &lt; currentModule.deps.length) {
      return printTree(depModule, depPrefix + " â”œâ”€â”€");
    } else {
      return printTree(depModule, depPrefix + " â””â”€â”€");
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>